---
layout: default
title: "Unit 3 - Systems and Control"
nav_order: 13
---

## Unit 3: Systems and Control (Python + EarSketch)
**Framing Concept: Programs model dynamic systems through control flow and state.**

### Unit Overview
This unit introduces students to **state** and **control structures** for the first time. After building comfort with pure functions and data transformation, they now learn what it means for a program to *remember*, *accumulate*, and *respond*. Using Python and the EarSketch audio platform, students explore loops, conditionals, and procedural logic. Then, we pivot into vanilla Python environments to build simulations and rule-based systems that move beyond music into models and games.

### Essential Questions
- What does it mean for a program to have memory or state?
- How do loops allow us to express repeated patterns or accumulations?
- What is the relationship between control structures and behavior?
- How can a program simulate or respond to real-world complexity?

### Core Learning Goals
- Use `for` and `while` loops to express repetition and iteration
- Understand and manipulate variables and accumulators
- Use `if`, `elif`, and `else` to build branching behaviors
- Translate structured ideas into procedural models
- Make sense of how Python differs from Racket and Pyret (syntax, state, flow)

### Core Activities
- **EarSketch Composition:** Students create procedural music tracks using repetition, parameters, and layered functions
- **Simulation Projects:** Build small rule-based simulations (e.g., traffic flow, visitor logic in galleries)
- **Story Logic:** Create interactive decision trees using conditionals and state-tracking
- **Walkthrough Debriefs:** Students trace code line-by-line to predict behavior and output

### Stretch + Extensions
- **Museum Soundscape Engine:** Link exhibits to conditional music triggers
- **Game Engine Lite:** Build a simple room-to-room text-based game using loops and state
- **Data-Driven Rulesets:** Link control structures to CSV inputs or user entry
- **Accumulator Patterns:** Model tallying, averaging, or conditional sums

### Transition to Broader Systems Thinking
This is the unit where control meets structure. Students shift from viewing a program as a function to seeing it as a **machine**—a system that moves, adapts, and evolves. It’s the first major introduction of **imperative style**, and prepares them to eventually understand object-oriented systems (in AP CS A or beyond).

### Assessment and Reflection
- Code walkthroughs: trace and predict program behavior
- Debugging challenges: identify and fix logic or accumulator errors
- Build + Explain: present a simulation with a logic diagram
- Journal: What’s different now that your program *remembers* something?

### End-of-Unit Statement
By the end of Unit 4, students know how to build programs that move, change, and respond. They have used loops and conditionals to model systems and build expressive logic. They are ready to move into design and interpretation—wrapping code in communication, interface, and inquiry.
